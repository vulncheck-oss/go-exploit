package config

import (
	"fmt"
	"strings"

	"github.com/vulncheck-oss/go-exploit/c2"
)

type ExploitType int

const (
	CodeExecution         ExploitType = 0
	InformationDisclosure ExploitType = 1
	Webshell              ExploitType = 2
	FileFormat            ExploitType = 3
	Local                 ExploitType = 4
)

type ImplementedFeatures struct {
	AssetDetection  bool
	VersionScanning bool
	Exploitation    bool
}

type SSLSupport int

const (
	SSLDisabled     SSLSupport = 0
	SSLEnabled      SSLSupport = 1
	SSLAutodiscover SSLSupport = 2
)

type RhostTriplet struct {
	Rhost string
	Rport int
	SSL   SSLSupport
}

// The config struct contains a mix of module specified configurations
// and user specified configurations. The Config struct is first generated
// by the exploit implementation and then modified by option parsing.
type Config struct {
	// the following are values configured by the exploit module

	// implemented features describes which three stages the exploit implements
	Impl ImplementedFeatures
	// the vendor of the targeted product
	Vendor string
	// the targeted products
	Products []string
	// A combination of the Vendor and Products strings
	Product string
	// the CPE for the targeted product
	CPE []string
	// the CVE being tested
	CVE string
	// the protocol being targeted
	Protocol string
	// the type of exploit being executed
	ExType ExploitType
	// the c2 supported by the exploit
	SupportedC2 []c2.Impl

	// the following are values configured by the user

	// target host, the target address/name the exploit will work on
	Rhost string
	// target port, the target port the exploit will work on
	Rport int
	// a list of specific targets
	RhostsNTuple []RhostTriplet
	// local host for remote exploits
	Lhost string
	// local port
	Lport int
	// bind port
	Bport int
	// indicates if the framework should autodetect ssl/plain
	DetermineSSL bool
	// indicates if ssl is used in comms
	SSL bool
	// indicates if we run the target verify
	DoVerify bool
	// indicates if we run the version check
	DoVersionCheck bool
	// indicates if we run the exploit
	DoExploit bool
	// the user requested c2 to use
	C2Type c2.Impl
	// C2 server timeout
	C2Timeout int
	// Indicates if the c2 server will be handled elsewhere
	ThirdPartyC2Server bool
	// The database we are working with
	DBName string
	// File format template
	FileTemplateData string
	// File format exploit output
	FileFormatFilePath string
}

// Convert ExploitType to String.
func (eType ExploitType) String() string {
	switch eType {
	case CodeExecution:
		return "CodeExecution"
	case InformationDisclosure:
		return "InformationDisclosure"
	case Webshell:
		return "Webshell"
	case FileFormat:
		return "FileFormat"
	case Local:
		return "Local"
	default:
		return "Invalid exploit type"
	}
}

// Deprecated: New does not affectively describe the affected/targeted product. Use NewRemoteExploit.
func New(extype ExploitType, supportedC2 []c2.Impl, product string, cve string, defaultPort int) *Config {
	returnVal := new(Config)
	returnVal.ExType = extype
	returnVal.SupportedC2 = supportedC2
	returnVal.Product = product
	returnVal.CVE = cve
	returnVal.Rport = defaultPort

	return returnVal
}

// Deprecated: NewLocal does not affectively describe the affected/targeted product. Use NewLocalExploit.
func NewLocal(extype ExploitType, supportedC2 []c2.Impl, product string, cve string) *Config {
	returnVal := new(Config)
	returnVal.ExType = extype
	returnVal.SupportedC2 = supportedC2
	returnVal.Product = product
	returnVal.CVE = cve

	return returnVal
}

// Defines a new remote exploit and associates with CVE/Product/Protocol metadata. Usage example:
//
//	conf := config.NewRemoteExploit(
//	  config.ImplementedFeatures{AssetDetection: true, VersionScanning: true, Exploitation: true},
//	  config.CodeExecution, []c2.Impl{c2.SimpleShellServer},
//	  "Atlassian", []string{"Confluence"}, []string{"cpe:2.3:a:atlassian:confluence"},
//	  "CVE-2023-22527", "HTTP", 8090)
func NewRemoteExploit(implemented ImplementedFeatures, extype ExploitType, supportedC2 []c2.Impl, vendor string,
	product []string, cpe []string, cve string, protocol string, defaultPort int,
) *Config {
	newConf := new(Config)
	newConf.Impl = implemented
	newConf.ExType = extype
	newConf.SupportedC2 = supportedC2
	newConf.Vendor = vendor
	newConf.Products = product
	newConf.Product = fmt.Sprintf("%s %s", vendor, strings.Join(product, "/"))
	newConf.CPE = cpe
	newConf.CVE = cve
	newConf.Protocol = protocol
	newConf.Rport = defaultPort

	return newConf
}

// Defines a new remote exploit and associates with CVE/Product/Protocol metadata. Usage example:.
func NewLocalExploit(implemented ImplementedFeatures, extype ExploitType, supportedC2 []c2.Impl, vendor string,
	product []string, cpe []string, cve string,
) *Config {
	newConf := new(Config)
	newConf.Impl = implemented
	newConf.ExType = extype
	newConf.SupportedC2 = supportedC2
	newConf.Vendor = vendor
	newConf.Products = product
	newConf.Product = fmt.Sprintf("%s %s", vendor, strings.Join(product, "/"))
	newConf.CPE = cpe
	newConf.CVE = cve

	return newConf
}
