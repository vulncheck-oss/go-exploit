package cli

import (
	"bufio"
	"flag"
	"fmt"
	"net"
	"os"
	"strconv"
	"strings"

	"github.com/vulncheck-oss/go-exploit/c2"
	"github.com/vulncheck-oss/go-exploit/config"
	"github.com/vulncheck-oss/go-exploit/output"
)

func inc(ip net.IP) {
	for j := len(ip) - 1; j >= 0; j-- {
		ip[j]++
		if ip[j] > 0 {
			break
		}
	}
}

func generateIPv4CIDR(cidr string) []string {
	cidrSlice := make([]string, 0)
	ip, ipNet, err := net.ParseCIDR(cidr)
	if err != nil {
		output.PrintFrameworkError(err.Error())

		return cidrSlice
	}

	for ip := ip.Mask(ipNet.Mask); ipNet.Contains(ip); inc(ip) {
		cidrSlice = append(cidrSlice, ip.String())
	}

	return cidrSlice
}

func buildRhosts(conf *config.Config, rhosts, rports string) bool {
	// convert the provided Rports to a slice of int
	rportsSlice := make([]int, 0)
	if rports != "" {
		splitPorts := strings.Split(rports, ",")
		for _, port := range splitPorts {
			portInt, err := strconv.Atoi(port)
			if err != nil {
				output.PrintfFrameworkError("Failed to convert provided rports: %s", err)

				return false
			}
			rportsSlice = append(rportsSlice, portInt)
		}
	} else {
		rportsSlice = append(rportsSlice, conf.Rport)
	}

	// convert the rhosts csv into a slice of strings
	rhostsSlice := make([]string, 0)
	if rhosts != "" {
		splitRhosts := strings.Split(rhosts, ",")
		for _, host := range splitRhosts {
			if strings.Contains(host, "/") {
				rhostsSlice = append(rhostsSlice, generateIPv4CIDR(host)...)
			} else {
				rhostsSlice = append(rhostsSlice, host)
			}
		}
	} else {
		rhostsSlice = append(rhostsSlice, conf.Rhost)
	}

	// determine the SSL status to assign everything
	SSL := config.SSLDisabled
	if conf.SSL {
		SSL = config.SSLEnabled
	} else if conf.DetermineSSL {
		SSL = config.SSLAutodiscover
	}

	// convert rhostsSlice and rportsSlices to many RhostTriplet. Obviously
	// this will consume a lot of memory if you provide a ton of ip/port combos
	// so probably just don't do that ok? Like 1 million is probably fine, right?
	// 1 billion, not so much.
	conf.RhostsNTuple = make([]config.RhostTriplet, 0)
	for iHost := range rhostsSlice {
		for iPort := range rportsSlice {
			triplet := config.RhostTriplet{
				Rhost: rhostsSlice[iHost],
				Rport: rportsSlice[iPort],
				SSL:   SSL,
			}
			conf.RhostsNTuple = append(conf.RhostsNTuple, triplet)
		}
	}

	return true
}

func parseRhostsFile(conf *config.Config, rhostsFile string) bool {
	hostsFile, err := os.Open(rhostsFile)
	if err != nil {
		output.PrintFrameworkError(err.Error())

		return false
	}
	defer hostsFile.Close()

	conf.RhostsNTuple = make([]config.RhostTriplet, 0)
	lineScan := bufio.NewScanner(hostsFile)
	for lineScan.Scan() {
		line := lineScan.Text()
		splitTriplet := strings.Split(line, ",")
		if len(splitTriplet) != 3 {
			output.PrintfFrameworkError("Invalid triplet: %s", line)

			return false
		}

		portInt, err := strconv.Atoi(splitTriplet[1])
		if err != nil {
			output.PrintfFrameworkError("Failed to convert the provided rport: %s", splitTriplet[1])

			return false
		}

		// determine the SSL status to assign everything
		SSL := config.SSLDisabled
		if splitTriplet[2] != "" {
			SSL = config.SSLEnabled
		}

		// this is sort of weird, but if someone provides a file of ips and ports but they aren't sure
		// about the ssl status, then it makes sense to pass in -a
		if conf.DetermineSSL {
			SSL = config.SSLAutodiscover
		}

		triplet := config.RhostTriplet{
			Rhost: splitTriplet[0],
			Rport: portInt,
			SSL:   SSL,
		}
		conf.RhostsNTuple = append(conf.RhostsNTuple, triplet)
	}

	return true
}

func handleRhostsOptions(conf *config.Config, rhosts, rports, rhostsFile string) bool {
	if rhostsFile != "" {
		return parseRhostsFile(conf, rhostsFile)
	}

	return buildRhosts(conf, rhosts, rports)
}

func commonValidate(conf *config.Config, rhosts, rports, rhostsFile string) bool {
	switch {
	case conf.Rhost == "" && rhosts == "" && rhostsFile == "":
		output.PrintFrameworkError("Missing required option 'rhost', 'rhosts', or 'rhosts-file'")

		return false
	case conf.Rport == 0 && rports == "" && rhostsFile == "":
		output.PrintFrameworkError("Missing required option 'rport', 'rports', or 'rhosts-file'")

		return false
	case conf.Rhost != "" && rhosts != "":
		output.PrintFrameworkError("'rhost' and 'rhosts' are mutually exclusive")

		return false
	case conf.Rhost != "" && rhostsFile != "":
		output.PrintFrameworkError("'rhost' and 'rhosts-file' are mutually exclusive")

		return false
	case rhosts != "" && rhostsFile != "":
		output.PrintFrameworkError("'rhosts' and 'rhosts-file' are mutually exclusive")

		return false
	case !conf.DoVerify && !conf.DoVersionCheck && !conf.DoExploit:
		output.PrintFrameworkError("Please provide an action (-v, -c, -e)")

		return false
	case conf.SSL && conf.DetermineSSL:
		output.PrintFrameworkError("-a and -s are mutually exclusive")

		return false
	}

	if rhostsFile != "" {
		_, err := os.Stat(rhostsFile)
		if err != nil {
			output.PrintfFrameworkError("Failed to stat %s: %s", rhostsFile, err)

			return false
		}
	}

	return true
}

// command line options for proxying.
func proxyFlags(proxy *string) {
	flag.StringVar(proxy, "proxy", "", "A proxy that will be used for all communication")
}

// Go can automatically handle HTTP proxying (if HTTP_PROXY env is set) and it can automatically
// handle HTTPS proxying (if HTTPS_PROXY env is set). It can't handle normal tcp socket proxying
// though, so we'll set ALL_PROXY for that (and handle the logic in protocol/tcpsocket.go).
func handleProxyOptions(proxy string) {
	if proxy == "" {
		return
	}
	os.Setenv("HTTP_PROXY", proxy)
	os.Setenv("HTTPS_PROXY", proxy)
	os.Setenv("ALL_PROXY", proxy)
}

// command line options for logging.
func loggingFlags(logFile, frameworkLogLevel, exploitLogLevel *string) {
	flag.BoolVar(&output.FormatJSON, "log-json", false, "Indicates if logging should use JSON")
	flag.StringVar(logFile, "log-file", "", "The file to write log messages to.")

	logLevels := ""
	for key := range output.LogLevels {
		logLevels += "\n" + key
	}

	flag.StringVar(frameworkLogLevel, "fll", "STATUS", "The minimum log level for the framework:"+logLevels)
	flag.StringVar(exploitLogLevel, "ell", "STATUS", "The minimum log level for the exploit:"+logLevels)
}

func handleLogOptions(logFile, frameworkLogLevel, exploitLogLevel string) bool {
	value, found := output.LogLevels[frameworkLogLevel]
	if !found {
		output.PrintFrameworkError("Invalid framework log level provided")

		return false
	}
	output.SetFrameworkLogLevel(value)

	value, found = output.LogLevels[exploitLogLevel]
	if !found {
		output.PrintFrameworkError("Invalid exploit log level provided")

		return false
	}
	output.SetExploitLogLevel(value)

	if logFile != "" && !output.SetOutputFile(logFile) {
		return false
	}

	return true
}

// command line flags for defining the remote host.
func remoteHostFlags(conf *config.Config, rhosts, rhostsFile, rports *string) {
	flag.StringVar(&conf.Rhost, "rhost", "", "The remote target's IP address")
	flag.StringVar(rhosts, "rhosts", "", "A comma delimited list of remote target IP addresses")
	flag.StringVar(rhostsFile, "rhosts-file", "", "A CSV containing a list of targets")
	// the Rport should be pre-configured to have a default value (see config.go:New())
	flag.IntVar(&conf.Rport, "rport", conf.Rport, "The remote target's server port")
	flag.StringVar(rports, "rports", "", "A comma delimited list of the remote target's server ports")
}

// command line flags for defining the local host.
func localHostFlags(conf *config.Config) {
	flag.StringVar(&conf.Lhost, "lhost", "", "The IP address the configured c2 will bind to")
	flag.IntVar(&conf.Lport, "lport", 0, "The port the configured c2 will bind to")
}

// command line flags that control the exploits behavior.
func exploitFunctionality(conf *config.Config) {
	flag.BoolVar(&conf.DoVerify, "v", false, "Verify the target is "+conf.Product)
	flag.BoolVar(&conf.DoVersionCheck, "c", false, "Perform a version check before attempting exploitation")
	flag.BoolVar(&conf.DoExploit, "e", false, "Exploit the target")
}

// command line flags that control ssl communication with the target.
func sslFlags(conf *config.Config) {
	flag.BoolVar(&conf.SSL, "s", false, "Use https to communicate with the target")
	flag.BoolVar(&conf.DetermineSSL, "a", false, "Automatically determine if the remote target uses SSL")
}

// Parses the command line arguments used by RCE exploits.
func CodeExecutionCmdLineParse(conf *config.Config) bool {
	var rhosts string
	var rhostsFile string
	var rports string
	var logFile string
	var frameworkLogLevel string
	var exploitLogLevel string
	var proxy string

	proxyFlags(&proxy)
	loggingFlags(&logFile, &frameworkLogLevel, &exploitLogLevel)
	remoteHostFlags(conf, &rhosts, &rhostsFile, &rports)
	localHostFlags(conf)
	exploitFunctionality(conf)
	sslFlags(conf)

	// flags unique to remote code execution
	flag.IntVar(&conf.Bport, "bport", 0, "The port to attach the bind shell to")
	flag.IntVar(&conf.C2Timeout, "t", 30, "The number of seconds to listen for reverse shells.")
	flag.BoolVar(&conf.ThirdPartyC2Server, "o", false, "Indicates if the reverse shell should be caught by an outside program (nc, openssl)")

	// c2 selection. defaults to the implementations first supported value
	var c2Selection string
	c2Default, _ := c2.ImplToString(conf.SupportedC2[0])
	c2Available := "The C2 server implementation to use. Supported: "
	for _, value := range conf.SupportedC2 {
		c2Name, ok := c2.ImplToString(value)
		if ok {
			c2Available += "\n\t" + c2Name
		}

		// add the supported c2 flags, allowing for command line config of the backend
		impl, success := c2.GetInstance(value)
		if success {
			impl.CreateFlags()
		}
	}
	c2Available += "\n"
	flag.StringVar(&c2Selection, "c2", c2Default, c2Available)

	flag.Usage = func() {
		// banner explaining what the software is
		fmt.Printf("An exploit for %s %s that can generate a reverse shell or bind shell\n\n", conf.Product, conf.CVE)

		// print default usage information
		flag.PrintDefaults()
	}
	flag.Parse()

	handleProxyOptions(proxy)

	// validate remaining command line arguments
	success := handleLogOptions(logFile, frameworkLogLevel, exploitLogLevel) &&
		commonValidate(conf, rhosts, rports, rhostsFile) && handleRhostsOptions(conf, rhosts, rports, rhostsFile)

	// validate a reverse shell or bind shell params are correctly specified
	if conf.DoExploit {
		c2Selected, ok := c2.StringToImpl(c2Selection)
		if !ok {
			output.PrintFrameworkError("Provided an invalid c2 implementation")
			success = false
		}
		// is this a supported c2?
		foundSupported := false
		for _, value := range conf.SupportedC2 {
			if c2Selected == value {
				foundSupported = true
			}
		}
		if !foundSupported {
			output.PrintFrameworkError("The c2 you selected is not supported by this exploit.")
			success = false
		}
		conf.C2Type = c2Selected

		if conf.Bport == 0 && (conf.Lport == 0 || conf.Lhost == "") {
			output.PrintFrameworkError("Missing exploitation options (bindshell or reverse shell)")
			success = false
		}
		if conf.Bport != 0 && conf.Lport != 0 {
			output.PrintFrameworkError("User specified both bind shell and reverse shell ports")
			success = false
		}
	}

	return success
}

func InformationDisclosureCmdLineParse(conf *config.Config) bool {
	var rhosts string
	var rhostsFile string
	var rports string
	var logFile string
	var frameworkLogLevel string
	var exploitLogLevel string
	var proxy string

	proxyFlags(&proxy)
	loggingFlags(&logFile, &frameworkLogLevel, &exploitLogLevel)
	remoteHostFlags(conf, &rhosts, &rhostsFile, &rports)
	localHostFlags(conf)
	exploitFunctionality(conf)
	sslFlags(conf)

	flag.Usage = func() {
		// banner explaining what the software is
		fmt.Printf("An exploit for %s %s that can leak sensitive data\n\n", conf.Product, conf.CVE)

		// print default usage information
		flag.PrintDefaults()

		// usage examples
		fmt.Println("Usage example:")
		fmt.Println("\t./exploit -v -c -e -a -rhost 10.12.70.247 -rport 443")
	}
	flag.Parse()

	handleProxyOptions(proxy)

	return handleLogOptions(logFile, frameworkLogLevel, exploitLogLevel) &&
		commonValidate(conf, rhosts, rports, rhostsFile) && handleRhostsOptions(conf, rhosts, rports, rhostsFile)
}

func WebShellCmdLineParse(conf *config.Config) bool {
	var rhosts string
	var rhostsFile string
	var rports string
	var logFile string
	var frameworkLogLevel string
	var exploitLogLevel string
	var proxy string

	proxyFlags(&proxy)
	loggingFlags(&logFile, &frameworkLogLevel, &exploitLogLevel)
	remoteHostFlags(conf, &rhosts, &rhostsFile, &rports)
	localHostFlags(conf)
	exploitFunctionality(conf)
	sslFlags(conf)

	flag.Usage = func() {
		// banner explaining what the software is
		fmt.Printf("An exploit for %s %s that drops a webshell\n\n", conf.Product, conf.CVE)

		// print default usage information
		flag.PrintDefaults()

		// usage examples
		fmt.Println("Usage example:")
		fmt.Println("\t./exploit -v -c -e -a -rhost 10.12.70.247 -rport 443")
	}
	flag.Parse()

	handleProxyOptions(proxy)

	return handleLogOptions(logFile, frameworkLogLevel, exploitLogLevel) &&
		commonValidate(conf, rhosts, rports, rhostsFile) && handleRhostsOptions(conf, rhosts, rports, rhostsFile)
}
