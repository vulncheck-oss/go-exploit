package protocol

import (
	"fmt"
	"io"
	"mime/multipart"
	"net"
	"net/http"
	"net/textproto"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/vulncheck-oss/go-exploit/output"
	"github.com/vulncheck-oss/go-exploit/transform"
)

var GlobalUA = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" +
	"(KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36 Edg/105.0.1343.33"

// Returns a valid HTTP/HTTPS URL provided the given input.
func GenerateURL(rhost string, rport int, ssl bool, uri string) string {
	url := ""
	if ssl {
		url += "https://"
	} else {
		url += "http://"
	}

	// is the address v6?
	ip := net.ParseIP(rhost)
	if ip != nil && ip.To4() == nil {
		rhost = "[" + rhost + "]"
	}

	url += rhost
	url += ":"
	url += strconv.Itoa(rport)
	url += uri

	return url
}

// Using the variable amount of paths, return a URI without any extra '/'.
func BuildURI(paths ...string) string {
	uri := "/"
	for _, path := range paths {
		if !strings.HasSuffix(uri, "/") && !strings.HasPrefix(path, "/") {
			uri += "/"
		}
		uri += path
	}

	return uri
}

// BasicAuth takes a username and password and returns a string suitable for an Authorization header.
func BasicAuth(username, password string) string {
	return fmt.Sprintf("Basic %s", transform.EncodeBase64(username+":"+password))
}

func parseCookies(headers []string) string {
	cookies := make([]string, len(headers))

	for i, cookie := range headers {
		cookies[i] = strings.Split(cookie, ";")[0]
	}

	return strings.Join(cookies, "; ")
}

// ParseCookies parses an HTTP response and returns a string suitable for a Cookie header.
func ParseCookies(resp *http.Response) string {
	return parseCookies(resp.Header.Values("Set-Cookie"))
}

// Go doesn't always like sending our exploit URI so use this raw version. SSL not implemented.
func DoRawHTTPRequest(rhost string, rport int, uri, verb string) bool {
	// connect
	conn, success := TCPConnect(rhost, rport)
	if !success {
		return false
	}

	// is the address v6?
	ip := net.ParseIP(rhost)
	if ip != nil && ip.To4() == nil {
		rhost = "[" + rhost + "]"
	}

	httpRequest := verb + " " + uri + " HTTP/1.1\r\n"
	httpRequest += "Host: " + rhost + ":" + strconv.Itoa(rport) + "\r\n"
	httpRequest += "User-Agent: " + GlobalUA + "\r\n"
	httpRequest += "Accept: */*\r\n"
	httpRequest += "\r\n"
	success = TCPWrite(conn, []byte(httpRequest))
	if !success {
		return false
	}

	// don't currently care about the response. Read a byte and move on'
	_, success = TCPReadAmount(conn, 1)

	return success
}

func DoRequest(client *http.Client, req *http.Request) (*http.Response, string, bool) {
	resp, err := client.Do(req)
	if err != nil {
		output.PrintfFrameworkError("HTTP request error: %s", err)

		return resp, "", false
	}

	defer resp.Body.Close()
	bodyBytes, _ := io.ReadAll(resp.Body)

	return resp, string(bodyBytes), true
}

// converts a map of strings into a single string in application/x-www-urlencoded format (but does not encode the params!)
func CreateRequestParams(params map[string]string) string {
	data := ""
	for key, element := range params {
		if len(data) > 0 {
			data += "&"
		}
		data += (key + "=" + element)
	}

	return data
}

// CreateRequestParamsEncoded is the encoded version of CreateRequestParams.
func CreateRequestParamsEncoded(params map[string]string) string {
	paramsCopy := make(map[string]string)

	for k, v := range params {
		paramsCopy[k] = url.QueryEscape(v)
	}

	return CreateRequestParams(paramsCopy)
}

func SetRequestHeaders(req *http.Request, headers map[string]string) {
	for key, value := range headers {
		if key == "Host" {
			// host can't be set directly
			req.Host = value
		} else {
			// don't use the Set function because the module might modify key. Set the header directly.
			req.Header[key] = []string{value}
		}
	}
}

func CreateRequest(verb, url, payload string, followRedirect bool) (*http.Client, *http.Request, bool) {
	var client *http.Client
	if !followRedirect {
		client = &http.Client{
			Timeout: 10 * time.Second,
			CheckRedirect: func(req *http.Request, via []*http.Request) error {
				return http.ErrUseLastResponse
			},
		}
	} else {
		client = &http.Client{
			Timeout: 10 * time.Second,
		}
	}
	req, err := http.NewRequest(verb, url, strings.NewReader(payload))
	if err != nil {
		output.PrintfFrameworkError("HTTP request creation error: %s", err)

		return nil, nil, true
	}

	// set headers on the request
	req.Header.Set("User-Agent", GlobalUA)

	return client, req, false
}

func HTTPSendAndRecv(verb, url, payload string) (*http.Response, string, bool) {
	client, req, err := CreateRequest(verb, url, payload, true)
	if err {
		return nil, "", false
	}

	return DoRequest(client, req)
}

func HTTPSendAndRecvNoRedirect(verb, url, payload string) (*http.Response, string, bool) {
	client, req, err := CreateRequest(verb, url, payload, true)
	if err {
		return nil, "", false
	}

	// ignore the redirect
	client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		return http.ErrUseLastResponse
	}

	return DoRequest(client, req)
}

func HTTPSendAndRecvURLEncoded(verb, url string, params map[string]string) (*http.Response, string, bool) {
	payload := CreateRequestParams(params)
	client, req, err := CreateRequest(verb, url, payload, true)
	if err {
		return nil, "", false
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	return DoRequest(client, req)
}

func HTTPSendAndRecvURLEncodedParams(verb, url string, params map[string]string) (*http.Response, string, bool) {
	payload := CreateRequestParamsEncoded(params)
	client, req, err := CreateRequest(verb, url, payload, true)
	if err {
		return nil, "", false
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	return DoRequest(client, req)
}

func HTTPSendAndRecvURLEncodedAndHeaders(verb, url string, params map[string]string,
	headers map[string]string,
) (*http.Response, string, bool) {
	payload := CreateRequestParams(params)

	client, req, err := CreateRequest(verb, url, payload, true)
	if err {
		return nil, "", false
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	SetRequestHeaders(req, headers)

	return DoRequest(client, req)
}

func HTTPSendAndRecvURLEncodedParamsAndHeaders(verb, url string, params map[string]string,
	headers map[string]string,
) (*http.Response, string, bool) {
	payload := CreateRequestParamsEncoded(params)

	client, req, err := CreateRequest(verb, url, payload, true)
	if err {
		return nil, "", false
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	SetRequestHeaders(req, headers)

	return DoRequest(client, req)
}

func HTTPSendAndRecvWithHeaders(verb, url, payload string, headers map[string]string) (*http.Response, string, bool) {
	client, req, err := CreateRequest(verb, url, payload, true)
	if err {
		return nil, "", false
	}

	SetRequestHeaders(req, headers)

	return DoRequest(client, req)
}

// this naming scheme is a little out of control.
func HTTPSendAndRecvWithHeadersNoRedirect(verb, url, payload string,
	headers map[string]string,
) (*http.Response, string, bool) {
	client, req, err := CreateRequest(verb, url, payload, true)
	if err {
		return nil, "", false
	}

	// ignore the redirect
	client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		return http.ErrUseLastResponse
	}

	SetRequestHeaders(req, headers)

	return DoRequest(client, req)
}

func MultipartCreateForm() (*strings.Builder, *multipart.Writer) {
	form := &strings.Builder{}
	w := multipart.NewWriter(form)

	return form, w
}

func MultipartAddField(writer *multipart.Writer, name, value string) bool {
	fw, err := writer.CreateFormField(name)
	if err != nil {
		return false
	}
	_, err = io.Copy(fw, strings.NewReader(value))

	return err == nil
}

func MultipartAddFile(writer *multipart.Writer, name, filename, ctype, value string) bool {
	// CreateFormFile doesn't expose Content-Type
	h := make(textproto.MIMEHeader)
	h.Set("Content-Disposition",
		fmt.Sprintf(`form-data; name=%q; filename=%q`, name, filename))
	h.Set("Content-Type", ctype)

	fw, err := writer.CreatePart(h)
	if err != nil {
		return false
	}
	_, err = io.Copy(fw, strings.NewReader(value))

	return err == nil
}
