package main

import (
	"os"
	"regexp"
	"strconv"

	"github.com/buger/jsonparser"
	"github.com/vulncheck-oss/go-exploit/output"
	"github.com/vulncheck-oss/go-exploit/protocol"
)

func main() {
	uri := "https://raw.githubusercontent.com/projectdiscovery/useragent/main/useragent_data.json"
	resp, body, ok := protocol.HTTPSendAndRecv("GET", uri, "")
	if !ok {
		return
	}

	if resp.StatusCode != 200 {
		output.PrintfError("Unexpected status code: %d %s", resp.StatusCode, body)

		return
	}

	// looking in tags for the latest Chrome on Windows whatever
	chromePattern := regexp.MustCompile(`^Chrome (\d+) on Windows \d+$`)

	// pattern to find the Safari string so we can drop everything after
	safariPattern := regexp.MustCompile(`^.*Safari/[\d\.]+`)

	// store the newest version as we loop through the data
	latestChromeUA := ""
	latestChromeVer := 0

	_, _ = jsonparser.ArrayEach([]byte(body), func(entry []byte, _ jsonparser.ValueType, _ int, _ error) {
		_, _ = jsonparser.ArrayEach(entry, func(tag []byte, _ jsonparser.ValueType, _ int, _ error) {
			matches := chromePattern.FindStringSubmatch(string(tag))
			if len(matches) == 2 {
				version, _ := strconv.Atoi(matches[1])
				if version > latestChromeVer {
					ua, _ := jsonparser.GetString(entry, "Raw")
					cleanedUA := safariPattern.FindString(ua)
					if cleanedUA != "" {
						latestChromeUA = cleanedUA
						latestChromeVer = version
					}
				}
			}
		}, "Tags")
	})

	if len(latestChromeUA) != 0 {
		_ = os.WriteFile("../protocol/http-user-agent.txt", []byte(latestChromeUA), 0o644)
	}
}
